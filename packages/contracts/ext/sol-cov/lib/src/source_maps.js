"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var instructions_1 = require("./instructions");
var RADIX = 10;
function getLocationByOffset(str) {
    var locationByOffset = { 0: { line: 1, column: 0 } };
    var currentOffset = 0;
    try {
        for (var _a = __values(str.split('')), _b = _a.next(); !_b.done; _b = _a.next()) {
            var char = _b.value;
            var location_1 = locationByOffset[currentOffset];
            var isNewline = char === '\n';
            locationByOffset[currentOffset + 1] = {
                line: location_1.line + (isNewline ? 1 : 0),
                column: isNewline ? 0 : location_1.column + 1,
            };
            currentOffset++;
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return locationByOffset;
    var e_1, _c;
}
exports.getLocationByOffset = getLocationByOffset;
// Parses a sourcemap string
// The solidity sourcemap format is documented here: https://github.com/ethereum/solidity/blob/develop/docs/miscellaneous.rst#source-mappings
function parseSourceMap(sourceCodes, srcMap, bytecodeHex, sources) {
    var bytecode = Uint8Array.from(Buffer.from(bytecodeHex, 'hex'));
    var pcToInstructionIndex = instructions_1.getPcToInstructionIndexMapping(bytecode);
    var locationByOffsetByFileIndex = _.map(sourceCodes, function (s) { return (_.isUndefined(s) ? {} : getLocationByOffset(s)); });
    var entries = srcMap.split(';');
    var lastParsedEntry = {};
    var instructionIndexToSourceRange = {};
    _.each(entries, function (entry, i) {
        // tslint:disable-next-line:no-unused-variable
        var _a = __read(entry.split(':'), 4), instructionIndexStrIfExists = _a[0], lengthStrIfExists = _a[1], fileIndexStrIfExists = _a[2], jumpTypeStrIfExists = _a[3];
        var instructionIndexIfExists = parseInt(instructionIndexStrIfExists, RADIX);
        var lengthIfExists = parseInt(lengthStrIfExists, RADIX);
        var fileIndexIfExists = parseInt(fileIndexStrIfExists, RADIX);
        var offset = _.isNaN(instructionIndexIfExists) ? lastParsedEntry.offset : instructionIndexIfExists;
        var length = _.isNaN(lengthIfExists) ? lastParsedEntry.length : lengthIfExists;
        var fileIndex = _.isNaN(fileIndexIfExists) ? lastParsedEntry.fileIndex : fileIndexIfExists;
        var parsedEntry = {
            offset: offset,
            length: length,
            fileIndex: fileIndex,
        };
        if (parsedEntry.fileIndex !== -1 && !_.isUndefined(locationByOffsetByFileIndex[parsedEntry.fileIndex])) {
            var sourceRange = {
                location: {
                    start: locationByOffsetByFileIndex[parsedEntry.fileIndex][parsedEntry.offset],
                    end: locationByOffsetByFileIndex[parsedEntry.fileIndex][parsedEntry.offset + parsedEntry.length],
                },
                fileName: sources[parsedEntry.fileIndex],
            };
            instructionIndexToSourceRange[i] = sourceRange;
        }
        else {
            // Some assembly code generated by Solidity can't be mapped back to a line of source code.
            // Source: https://github.com/ethereum/solidity/issues/3629
        }
        lastParsedEntry = parsedEntry;
    });
    var pcsToSourceRange = {};
    try {
        for (var _a = __values(_.keys(pcToInstructionIndex)), _b = _a.next(); !_b.done; _b = _a.next()) {
            var programCounterKey = _b.value;
            var pc = parseInt(programCounterKey, RADIX);
            var instructionIndex = pcToInstructionIndex[pc];
            pcsToSourceRange[pc] = instructionIndexToSourceRange[instructionIndex];
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return pcsToSourceRange;
    var e_2, _c;
}
exports.parseSourceMap = parseSourceMap;
//# sourceMappingURL=source_maps.js.map